from pytubefix import Playlist  # video/playlist info
from pytubefix import YouTube  # video/playlist info
import json  # for custom parameters
import cv2  # for song image
import music_tag  # mp3 file data editor
import requests  # song info and image
from PIL import Image  # song image from youtube modifier
from io import BytesIO  # song image importer from the web
import os  # to delete temporary image after

playlist = "https://www.youtube.com/playlist?list=PLG5Wd810mzkqNOoh-bK5j7pkS-wZew2-v"
folder = "Result"
modifications = "Modifications.json"
Debug = True

playlist = Playlist(playlist)

# create files
with open("couldNotFind.txt", "w") as file:
    pass
with open("Console.txt", "w") as file:
    pass
with open(modifications, "r+") as file:
    if file.read() == "":
        file.seek(0)
        file.write("{}")
        file.truncate()
if not os.path.exists(folder):
    os.makedirs(folder)


# create a log entry
def log(*args):
    with open("Console.txt", "a") as file:
        file.write("\n" + " ".join(map(str, args)))


# clean strings to use in a itunes search, for example
def clean_string(input_string: str) -> str:  # by @protouncreative on discord 5/12/24
    output = ""
    for _, c in enumerate(input_string):
        if (ord(c) > 128) or (c == "\\") or (c == "?"):
            output += "_"
        else:
            output += c

    return output


counter = 0
counter_width = len(str(len(playlist.videos)))

for video in playlist.videos:
    # YT Information
    YTtitle = video.title
    YTartist = video.author
    YTyear = int(str(video.publish_date)[:4])
    YTimage = video.thumbnail_url
    link = video.watch_url

    # get rid of the - topic thing at the end of the artist name, usually for autogenerated song artists
    if YTartist.endswith(" - Topic"):
        YTartist = YTartist.split(" - Topic")[0]

    print(f"{counter:0{counter_width}}", YTtitle)

    # log YT Information
    log("--------------------------------------------------")
    log(f"#{counter:0{counter_width}}")
    log("Youtube:") if Debug else None
    log("    Title:", YTtitle) if Debug else None
    log("    Artist:", YTartist) if Debug else None
    log("    Year:", YTyear) if Debug else None
    log("    Image:", YTimage) if Debug else None
    log("    Link:", link) if Debug else None

    counter += 1

    # check for a custom search query in the modifications file
    with open(modifications, "r") as file:
        customData = json.load(file)
        try:
            # use custom given search query
            searchQuery = clean_string(customData[YTtitle]["searchquery"])
        except:
            # use given YT Title and YT Artist
            searchQuery = clean_string(YTtitle + " " + YTartist)
        finally:
            # replace all "&" with "and" and all spaces with %20's
            searchQuery = searchQuery.replace("&", "and").replace(" ", "%20")

    # log the search query used, and the link of the query
    log("\nsearch query:", searchQuery) if Debug else None
    (
        log(
            "search link:",
            f"https://itunes.apple.com/search?term={searchQuery}&entity=song",
        )
        if Debug
        else None
    )
    response = requests.get(
        f"https://itunes.apple.com/search?term={searchQuery}&entity=song"
    )
    try:
        response = response.json()
    except:
        # if no response, try again
        response = requests.get(
            f"https://itunes.apple.com/search?term={searchQuery}&entity=song"
        )
        try:
            response = response.json()
        except:
            # give up lil bro
            log("failed response:", response) if Debug else None
            response["resultCount"] = 0

    if response["resultCount"] == 0:
        # if theres no results for the query, set all IT Information to None
        ITtitle, ITartist, ITyear, ITalbum, ITimage, ITgenre, ITnumber = (None,) * 7

        with open("couldNotFind.txt", "a") as file:
            with open(modifications, "r") as f:
                customData = json.load(f)
                YTtitle = clean_string(YTtitle)

                if (YTtitle not in customData) or (
                    "searchquery" not in customData[YTtitle]
                ):  # entry DNE or search query wasnt given
                    file.write("Song:\n")
                    file.write("    Title: " + YTtitle + "\n")
                    file.write("    Artist: " + YTartist + "\n")

                elif "searchquery" in customData[YTtitle]:  # search query WAS given
                    file.write("Song:\n")
                    file.write("    Given search query: " + searchQuery + "\n")
                    file.write("    Title: " + YTtitle + "\n")
                    file.write("    Artist: " + YTartist + "\n")
    else:
        # there was a result, use the info given
        try:
            # use the given seachitem number in the modifications file
            with open(modifications, "r") as file:
                customData = json.load(file)
                result_number = int(customData[YTtitle]["searchitem"])
                log(f"search item used: {result_number}") if Debug else None
                iTunes_Result = response["results"][result_number]
        except:
            # no searchitem number given, use the first result
            iTunes_Result = response["results"][0]

        # IT Information
        ITtitle = iTunes_Result["trackName"]
        ITartist = iTunes_Result["artistName"]
        ITyear = int(str(iTunes_Result["releaseDate"])[:4])
        ITalbum = iTunes_Result["collectionName"]
        ITimage = iTunes_Result["artworkUrl100"]
        ITgenre = iTunes_Result["primaryGenreName"]
        ITnumber = iTunes_Result["trackNumber"]

        # if the album name ends with - single, remove it, and use the title as the album name
        if ITalbum.endswith(" - Single"):
            ITalbum = ITtitle
            ITnumber = 0
        # else:
        #     ITalbum = ITalbum.split(" - Single")[0]

    # log IT Information
    log("\niTunes:") if Debug else None
    log("    Title:", ITtitle) if Debug else None
    log("    Artist:", ITartist) if Debug else None
    log("    Year:", ITyear) if Debug else None
    log("    Album:", ITalbum) if Debug else None
    log("    Image:", ITimage) if Debug else None
    log("    Genre:", ITgenre) if Debug else None
    log("    Number:", ITnumber) if Debug else None

    with open(modifications, "r") as file:
        # go through custom modifications from the modifications file
        customData = json.load(file)

        # use custom title, if not use IT title, if not use YT title, and repeat
        title = customData.get(YTtitle, {}).get("title") or ITtitle or YTtitle
        artist = customData.get(YTtitle, {}).get("artist") or ITartist or YTartist
        year = customData.get(YTtitle, {}).get("year") or ITyear or YTyear
        album = (
            customData.get(YTtitle, {}).get("album")
            or ITalbum
            or "unknown; add in Modifications"
        )
        genre = customData.get(YTtitle, {}).get("genre") or ITgenre or "unknown"
        number = customData.get(YTtitle, {}).get("number", ITnumber) or 0

        try:
            # use the image link from the modifications file
            image = customData[YTtitle]["image"]
            response = requests.get(image)

            if response.status_code == 200:
                # if an image is returned from the link, use it
                image = Image.open(BytesIO(response.content))
                image.save("album_art.png")
            else:
                # or else it didnt download
                log("\nFailed to download the image:", image) if Debug else None

        except:
            # custom image link was not given
            if ITimage:
                # use IT image link

                # replace part of the url so it returns a higher resolution
                image = ITimage.replace("100x100bb", "10000x10000bb")
                response = requests.get(image)

                if response.status_code == 200:
                    # if an image is returned, use it
                    image = Image.open(BytesIO(response.content))
                    image.save("album_art.png")

                else:
                    # or else it didnt download
                    log("Failed to download the image:", image) if Debug else None

            else:
                # use YT video, and capture a frame for the album art
                max_retries = 3
                retry_count = 0
                while retry_count < max_retries:
                    try:
                        YouTube(link).streams.filter(only_video=True).order_by(
                            "resolution"
                        ).desc().first().download(filename="temp_image_vid.mp4")
                        break
                    except Exception as e:
                        retry_count += 1
                        if retry_count == max_retries:
                            print(
                                YouTube(link)
                                .streams.filter(only_video=True)
                                .order_by("resolution")
                                .desc()
                            )
                            print(
                                YouTube(link)
                                .streams.filter(only_video=True)
                                .order_by("resolution")
                                .desc()
                                .first()
                            )
                            print(
                                f"Failed to download image for album art after {max_retries} attempts: {str(e)}"
                            )
                            raise
                        print(f"Download attempt {retry_count} failed, retrying...")
                video_capture = cv2.VideoCapture("temp_image_vid.mp4")
                success, frame = video_capture.read()

                if success:
                    # if the frame was able to be captured
                    cv2.imwrite("album_art.png", frame)
                    image = Image.open("album_art.png")

                    width, height = image.size
                    new_dimension = min(width, height)

                    # crop to the center 1:1 part
                    left = (width - new_dimension) / 2
                    top = (height - new_dimension) / 2
                    right = left + new_dimension
                    bottom = top + new_dimension
                    image = image.crop((left, top, right, bottom))
                    image.save("album_art.png")
                else:
                    # couldnt capture frame from video
                    log("Failed to capture the image from video.") if Debug else None
                    temp_image = False

                video_capture.release()
                os.remove("temp_image_vid.mp4")

    # so when writing the file it doesnt break
    title = title.replace("/", " ").replace('"', " ")

    # log Final Information
    log("\nFinal:")
    log("    Title:", title)
    log("    Artist:", artist)
    log("    Year:", year)
    log("    Album:", album)
    # print(image)
    log("    Genre:", genre)
    log("    Number:", number)

    # download the highest quality audio with retries
    max_retries = 3
    retry_count = 0
    while retry_count < max_retries:
        try:
            YouTube(link).streams.filter(only_audio=True).order_by(
                "abr"
            ).desc().first().download(filename=f"{title}.webm")
            break
        except Exception as e:
            retry_count += 1
            if retry_count == max_retries:
                print(
                    f"Failed to download song audio after {max_retries} attempts: {str(e)}"
                )
                raise
            print(f"Download attempt {retry_count} failed, retrying...")

    # rename it, and put it in the folder
    os.system(
        f'ffmpeg -y -i "{title}.webm" -vn -ab 320k "{folder}/{title}.mp3" -loglevel quiet'  # -loglevel quiet
    )
    try:
        os.remove(f"{title}.webm")
    except Exception as exception:
        print(f"filename: {title}")
        print(f"error: {exception}")

    # add metadata to the file
    audiofile = music_tag.load_file(f"{folder}/{title}.mp3")
    audiofile["tracktitle"] = title
    audiofile["artist"] = artist
    audiofile["album"] = album
    audiofile["year"] = str(year)
    audiofile["genre"] = genre
    audiofile["discnumber"] = number

    # set the album art too
    with open("album_art.png", "rb") as artwork:
        audiofile["artwork"] = artwork.read()

    # save the changes
    audiofile.save()

# delete the temporary files
os.remove("album_art.png")
# os.remove("temp_image_vid.mp4")
